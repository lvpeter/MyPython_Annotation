import asyncio
import pymysql
import re
import threading
import time
import warnings

"""
简单的支线程
"""

class _Thread_GO(threading.Thread):
    def __init__(self,func,*args,**kwargs):
         super().__init__()
         self.func=func
         self.args=args
         self.kwargs=kwargs
    def run(self):
        self.func(*self.args,**self.kwargs)


# go=GO_Thread()
# @go.go(x=1)
# def mode(x):
#   print(x)
#
#>>  x=1

class GO_Thread:
    def __init__(self):
         self.__active:dict={}
         self.__predicted:list=[]
         self.loop=asyncio.get_event_loop()
         self.__prepare()
    def __prepare(self):
        def run(self):
            self.loop.run_until_complete(self.__timer_clear())
        _Thread_GO(run,self).start()
    async def __timer_clear(self):
          errtime=10
          while True:
              try:
                  await asyncio.sleep(10)
                  for k in self.__active:
                       if not self.isAlive(k):
                            self.remove(k)

                  errtime=10
              except Exception as e:
                  print(e)
                  time.sleep(errtime)
                  errtime*=1.5
                  if errtime>100:
                      warnings.warn("Go Thread clear  Error ",errtime," exit")
                      break

    def isAlive(self,name):
          if not isinstance(name,str):
              name=name.__name__
          return  self.__active[name].isAlive()
    def go(self,*args,**kwargs):

          def func(f):
                T=_Thread_GO(f,*args,**kwargs)
                self.__active[f.__name__] = T
                T.start()
                return f
          return func
    def getTask(self,f):
        task = self.__active.get(f.__name__)
        if not task is None:
            return task
        return None
    def remove(self,f):

         task=self.__active.get(f)
         if not  task is None:
             del self.__active[f]
             print("func :",f," del ok")
             return  True
         return  False


"""
 “数据库” 
"""
class SQL_Format:
    def __init__(self,dields,data,SQL):
        """
        :param dields: 字段
        :param data: 查询数据
        :param SQL:  你的数据库语句
        """
        self.data:list=data
        self.fields:dict=dields
        self.SQL:str=SQL
class Mytion_SQL:
    def __init__(self,
                 host
                 ,user,
                 passwd,
                 port:int=3306,
                 database:str=""):
        self.__user=user
        self.__passwd=passwd
        self.__port=port
        self.__err=None
        self.__database=database
        self.__MapFunc:dict={}
        self.loop=asyncio.get_event_loop()
        self.__isConnect=True
        self.__MOTION={"exec":self.__exec,"insert":self.__exec,"update":self.__exec,"query":self.__query,"delete":self.__exec}
        try:
             self.__MYSQL=pymysql.Connect(host=host,user=user,password=passwd,port=port,database=database)
             self.__isConnect = True
        except Exception as e:
            print(e)
            self.__isConnect=False

    def begin(self,
                 host
                 ,user,
                 passwd,
                 port:int=3306,
                 database:str=""):
        try:
            self.__MYSQL = pymysql.Connect(host=host, user=user, password=passwd, port=port, database=database)
            self.__isConnect = True
        except Exception as e:
            print(e)
            self.__isConnect = False
    def close(self):
        self.__isConnect=False
        self.__MYSQL.close()
    def err(self,*args,**kwargs):
        """  注意异常处理方法必须带有 必须带有最少一个参数 第一个参数是 返回异常的 param数量必须少异常处理的数量
        :param args: 你给异常的参数
        :param kwargs:  你给异常的参数
        :return:
        """
        def defaultFunc(f):


            if f.__code__.co_argcount<1:
                  warnings.warn("ErrFunc param null")
            elif f.__code__.co_argcount-(len(args)+len(kwargs))!=1:
                 warnings.warn( "ErrFunc param 没预留第一个参数")
            else:
                self.__err={"func":f,"args":args,"kwargs":kwargs}
            return f


        return defaultFunc
    def query_DataToMap(self,fields,datas):
        try:
          assert isinstance(fields,dict) or len(fields)!=0 ,"fields none"
          assert isinstance(fields,dict) or len(datas)!=0, "data none"
          dataArray:list=[]
          if len(fields)==len(datas[0]):
                  for n in datas:
                      now:dict={}
                      for k,v in enumerate(fields):
                          now[str(v[0])]=n[k]
                      dataArray.append(now)
                  return dataArray
          else:
                  raise Exception("field != data value")

        except Exception as e:
            if self.__err is None:
                 warnings.warn( "ErrFunc param null")
            else:
                self.__err["func"](e,*self.__err["args"],**self.__err["kwargs"])

    def __query(self,exec:str):
        try:
            assert self.__isConnect, "not connet mysql"
            cursor=self.__MYSQL.cursor()
            cursor.execute(exec)
            fcursor=cursor.fetchall()
            cursor.close()
            return {"fields": cursor.description, "data": fcursor}
        except Exception as e:

            if self.__err is None:
                warnings.warn( "ErrFunc param null")
            else:
                self.__err["func"](e, *self.__err["args"], **self.__err["kwargs"])

            return {"fields":None, "data":None}

    async def __exec(self,exec:str):
        try:
            assert self.__isConnect, "not connet mysql"
            cursor = self.__MYSQL.cursor()
            cursor.execute(exec)
            self.__MYSQL.commit()
            cursor.close()
        except Exception as e:
            if self.__err is None:
                 warnings.warn( "ErrFunc param null")
            else:
                self.__err["func"](e, *self.__err["args"], **self.__err["kwargs"])

    def cursor(self,exec:str):
        try:
            assert self.__isConnect, "not connet mysql"
            cursor = self.__MYSQL.cursor()
            cursor.execute(exec)
            self.__MYSQL.commit()
            return cursor
        except Exception as e:
            if self.__err is None:
                 warnings.warn( "ErrFunc param null")
            else:
                self.__err["func"](e, *self.__err["args"], **self.__err["kwargs"])
            return  None

    def switch(self,types:str="exec"):
           """
           :param types:  标记你属于什么操作 注意方法名称不要重复 引起覆盖
           :return:
           """
           try:
               if types is None:
                   raise Exception("None")
               assert ["exec","insert","update","delete","query"].count(types)==1,"not select"
               if  ["exec","insert","update","delete","query"].count(types)==1:
                   def defaultFunc(f):
                       self.__MapFunc[f.__name__]={"origin":types,"func":f}
                       return f
               else:
                   def defaultFunc(f):
                       return f
               return  defaultFunc
           except Exception as e:
               if self.__err is None:
                    warnings.warn( "ErrFunc param null")
               else:
                   self.__err["func"](e, *self.__err["args"], **self.__err["kwargs"])
               return None

    def run(self,objectname,*args,**kwargs):
            """
            :param objectname:   你调用的方法 可以是function 也可以是字符串
            :param args:  query情况下 传递的参数 要是有sql query语句会执行 然后结果返回给之前的那个参数覆盖
            :param kwargs:  query情况下 传递的参数 要是有sql query语句会执行 然后结果返回给之前的那个参数覆盖
            :return: query情况下 你的方法要是有返回值 那就调用后返回，其他情况返回None

            """
            try:
                assert  not objectname is None,"objectname none"
                func=None
                if isinstance(objectname,str):
                    func = objectname
                else:
                    func=objectname.__name__

                assert not func is None, "objectname no func or str"
                func=self.__MapFunc.get(func)
                assert not func is None, "function no insert map "
                if func["origin"]=="query":
                    if func["func"].__code__.co_argcount<1:
                        raise Exception("parame length min 1")
                    else:
                         nowlist=[]
                         for i,v in enumerate(args):

                             if isinstance(v,str):
                                 if re.findall("^\s*?select.+$",v).__len__()>0:
                                     result=self.__query(v)
                                     nowlist.append(  SQL_Format(result["fields"],self.query_DataToMap(result["fields"],result["data"]),v))
                                 else:
                                     nowlist.append(v)
                             else:
                                 nowlist.append(v)

                         for k in kwargs:
                             if isinstance(kwargs[k], str):
                                 if re.findall("^\s*?select.+$", kwargs[k]).__len__() > 0:
                                     result = self.__query(kwargs[k])
                                     kwargs[k] = SQL_Format(result["fields"],self.query_DataToMap(result["fields"],result["data"]),kwargs[k])



                         return func["func"](*nowlist, **kwargs)

                else:
                    SQL=func["func"](*args,**kwargs)
                    self.loop.run_until_complete(self.__exec(SQL))
                    return None
            except Exception as e:
                if self.__err is None:
                     warnings.warn( "ErrFunc param null")
                else:
                    self.__err["func"](e, *self.__err["args"], **self.__err["kwargs"])
                return None








